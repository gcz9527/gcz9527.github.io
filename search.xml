<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML</title>
    <url>/2021/04/21/HTML/</url>
    <content><![CDATA[<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><p>字体标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>规定文本的字体、字体的尺寸、字体颜色</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;3&quot;</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>段落标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定一个段落</p>
<p>注释标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!----&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写程序时，给代码的解释或提示，能提高程序代码的可读性，以便于以后的参考、修改</p>
<p>标题标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h?</span>&gt;</span><span class="tag">&lt;/<span class="name">h?</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义标题头的六个不同文字大小，依次显示重要性的递减，也就是权重依次降低</p>
<p>a标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用超级链接与网络上的另一个文档相连</p>
<p>锚点标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;ziti&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同一个文档中创建指向该锚的链接</p>
<p>无序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此列项目使用粗体圆点进行标记</p>
<p>有序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>列表项目使用数字进行标记</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>table、caption、tr、th、td、border、width等</p>
<p>用于表格、行、列、宽度、边框的制作</p>
<p>合并行列</p>
<p>colspan、rowspan</p>
<p>用于将表格内的某些行、列进行合并</p>
<p>属性标签</p>
<p>caption、tbody、tfoot、thead</p>
<p>用于分组设置表格的格式</p>
<h3 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h3><table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">border</td>
<td align="center">设置边框</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">表格宽度</td>
</tr>
<tr>
<td align="center">bgcolor</td>
<td align="center">表格背景</td>
</tr>
<tr>
<td align="center">align</td>
<td align="center">表格在文档中的对齐方式</td>
</tr>
<tr>
<td align="center">cellpadding</td>
<td align="center">内容和边框之间的间距</td>
</tr>
<tr>
<td align="center">cellspacing</td>
<td align="center">单元格之间的间距</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">属性值</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">frame</td>
<td align="center">void</td>
<td align="center">不限时外边框</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">border</td>
<td align="center">四周都显示</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">above</td>
<td align="center">显示下部的外边框</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">below</td>
<td align="center">显示下部的外边框</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">hsides</td>
<td align="center">显示上下的外边框</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lhs</td>
<td align="center">显示左部的外边框</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">rhs</td>
<td align="center">显示右部的外边框</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">vsides</td>
<td align="center">显示左右的外边框</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性值</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rules</td>
<td align="center">none</td>
<td align="center">内边框将不被显示</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">rows</td>
<td align="center">内边框将在行之间显示</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">cols</td>
<td align="center">内边框在列之间显示</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">all</td>
<td align="center">内边框将被显示</td>
</tr>
<tr>
<td align="center">align</td>
<td align="center">left、center、right</td>
<td align="center">三种水平对齐方式</td>
</tr>
<tr>
<td align="center">valign</td>
<td align="center">bottom、middle、top</td>
<td align="center">三种垂直对齐方式</td>
</tr>
</tbody></table>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">指定控件的名称，可重复</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">指定标签的唯一标识</td>
</tr>
<tr>
<td align="center">value</td>
<td align="center">输入控件的值</td>
</tr>
<tr>
<td align="center">checked</td>
<td align="center">复选框组默认被选中的项目</td>
</tr>
<tr>
<td align="center">selected</td>
<td align="center">列表框组默认被选中的项目</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">图片框的图片来源</td>
</tr>
<tr>
<td align="center">onclick</td>
<td align="center">鼠标单击事件</td>
</tr>
<tr>
<td align="center">disabled</td>
<td align="center">禁用该控件</td>
</tr>
<tr>
<td align="center">multiple</td>
<td align="center">允许多选</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java慕课</title>
    <url>/2021/04/13/Java%E6%85%95%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h1><h2 id="第一周-环境搭建与语法入门"><a href="#第一周-环境搭建与语法入门" class="headerlink" title="第一周 环境搭建与语法入门"></a>第一周 环境搭建与语法入门</h2><h3 id="第一节-Java初识"><a href="#第一节-Java初识" class="headerlink" title="第一节 Java初识"></a>第一节 Java初识</h3><p>JVM（Java Virtual Machine）Java虚拟机，JVM是Java平台无关性实现的关键；</p>
<p>Java程序执行过程：</p>
<p>源文件-编辑器compiler&gt;字节码文件-解释器interpreter&gt;Program</p>
<p>JDK（Java Development Kit）Java语言的软件开发工具包</p>
<p>​    java-编译器，将源码转成字节码</p>
<p>​    java-运行编辑后的Java程序（.class后缀的）</p>
<p>JRE（Java Runtime Environment）包括Java虚拟机、Java核心类库和支持文件</p>
<p>三者关系：JDK=JRE+开发工具集</p>
<p>​                    JRE=JVM+JavaSE标准类库</p>
<p>Java平台</p>
<p>Java SE桌面程序 ；Java EEweb程序；Java ME移动设备</p>
<h3 id="第二节-Java语法之循环、数组和方法"><a href="#第二节-Java语法之循环、数组和方法" class="headerlink" title="第二节 Java语法之循环、数组和方法"></a>第二节 Java语法之循环、数组和方法</h3> <a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java慕课</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/10/20/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6> <a id="more"></a>

<h2 id="2-段落"><a href="#2-段落" class="headerlink" title="2.段落"></a>2.段落</h2><p> 2*空格+回车</p>
<h2 id="3-列表（-）"><a href="#3-列表（-）" class="headerlink" title="3.列表（* + -）"></a>3.列表（* + -）</h2><ul>
<li><p>第一项</p>
<ul>
<li><p>第二项</p>
<ul>
<li>第三项</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-区块（-gt-）"><a href="#4-区块（-gt-）" class="headerlink" title="4.区块（&gt;）"></a>4.区块（&gt;）</h2><blockquote>
<p>最外层</p>
<blockquote>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5-代码（-）"><a href="#5-代码（-）" class="headerlink" title="5.代码（````）"></a>5.代码（````）</h2><p><code> &lt;html&gt;&lt;/html&gt;</code>标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">​```</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>代码块<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h2><p>[链接名称]（链接地址）或者&lt;链接地址&gt;</p>
<p>Google <a href="https://www.google.com/">Google</a></p>
<h2 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h2><p><code> ![alt 属性文本]（图片地址 “可选标题”）</code></p>
<p><img src="" alt="alt 属性文本"></p>
<h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;</span><br><span class="line">｜ 表头  ｜ 表头 ｜</span><br><span class="line">｜ ---  ｜ ---  ｜</span><br><span class="line">｜ 单元格｜ 单元格 ｜</span><br><span class="line">｜ 单元格 ｜ 单元格 ｜ </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="9-高级技巧"><a href="#9-高级技巧" class="headerlink" title="9.高级技巧"></a>9.高级技巧</h2><p> <a href="https://www.runoob.com/markdown/md-advance.html">Markdown高级技巧</a></p>
]]></content>
      <categories>
        <category>规则</category>
      </categories>
      <tags>
        <tag>Md语法</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2020/10/21/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1-新建文件"><a href="#1-新建文件" class="headerlink" title="1.新建文件"></a>1.新建文件</h2><p><code> hexo n [name]</code></p>
<h2 id="2-本地操作"><a href="#2-本地操作" class="headerlink" title="2.本地操作"></a>2.本地操作</h2><p><code> hexo clean 清除</code></p>
<p><code> hexo s 启动服务</code></p>
<h2 id="3-提交仓库"><a href="#3-提交仓库" class="headerlink" title="3.提交仓库"></a>3.提交仓库</h2><p><code>hexo clean &amp; hexo deploy</code></p>
 <a id="more"></a>]]></content>
      <categories>
        <category>规则</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java8/9/11新特性</title>
    <url>/2020/12/09/java8-9-11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码。</p>
<p>“-&gt;”操作符将Lambda表达式拆成两部分：</p>
<p>左侧：Lambda表达式的参数列表</p>
<p>右侧：Lambda表达式中所需执行的功能，即Lambda体</p>
<p><strong>语法格式一：无参数，无返回值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">()-&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>语法格式二：有一个参数，无返回值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(a)-&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h1 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h1><h1 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h1><p><a href="https://www.bilibili.com/video/av59549886/?p=3">视频地址</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/10/21/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>2020年10月</p>
<p>如何学习Java300集</p>
<p>学习价值观：</p>
<p>知识体系建立为第一目标；</p>
<p>遇到难点不纠结，一个月后再会看难点。</p>
<h1 id="Java入门"><a href="#Java入门" class="headerlink" title="Java入门"></a>Java入门</h1><h2 id="计算机发展史和未来方向"><a href="#计算机发展史和未来方向" class="headerlink" title="计算机发展史和未来方向"></a>计算机发展史和未来方向</h2><p>计算机核心为：算法，语言是实现算法的工具；</p>
<p>机器语言-&gt;汇编语言-&gt;高级语言</p>
<h2 id="多种编程语言介绍"><a href="#多种编程语言介绍" class="headerlink" title="多种编程语言介绍"></a>多种编程语言介绍</h2><p>C语言、C++、Java语言、PHP、Object-C/Swift（苹果、JavaScript、Python、C#、Fortran、Basic</p>
<h2 id="Java的发展历史和未来"><a href="#Java的发展历史和未来" class="headerlink" title="Java的发展历史和未来"></a>Java的发展历史和未来</h2><p>1991年，SUN公司的Green项目，Oak</p>
<p>1996年，JDK1.0</p>
<p>1998年，JDK1.2</p>
<p>2014年，JDK8.0</p>
<h2 id="Java的核心优势和生态体系"><a href="#Java的核心优势和生态体系" class="headerlink" title="Java的核心优势和生态体系"></a>Java的核心优势和生态体系</h2><p>核心优势：跨平台</p>
 <a id="more"></a>

<h2 id="Java三大版本含义"><a href="#Java三大版本含义" class="headerlink" title="Java三大版本含义"></a>Java三大版本含义</h2><p>JavaSE（Java Standard Edition）标准版，定位在个人计算机上的应用；</p>
<p>JavaEE(Java Enterprise Edition) 企业版，定位在服务器端的应用；</p>
<p>JavaME(Java Micro Edition)微型版，定位在消费电子产品的应用上；</p>
<h2 id="Java的特性和优势"><a href="#Java的特性和优势" class="headerlink" title="Java的特性和优势"></a>Java的特性和优势</h2><p>跨平台/可移植性；</p>
<p>安全性；</p>
<p>面向对象性；</p>
<p>简单性；</p>
<p>高性能；</p>
<p>分布式；</p>
<p>多线程；</p>
<p>健壮性；</p>
<h2 id="Java应用程序的运行机制"><a href="#Java应用程序的运行机制" class="headerlink" title="Java应用程序的运行机制"></a>Java应用程序的运行机制</h2><p><code>源文件（*.java）-&gt;Java编辑器-&gt;字节码文件（*.class）</code></p>
<p>运行在JRE，JRE运行在系统平台；</p>
<p>Java是编译型+解释型的语言；</p>
<h2 id="JDK、JRE、JVM的作用和区别"><a href="#JDK、JRE、JVM的作用和区别" class="headerlink" title="JDK、JRE、JVM的作用和区别"></a>JDK、JRE、JVM的作用和区别</h2><p>JVM（Java Vitual Machine）就是一个虚拟的用于执行bytecode字节码的虚拟计算机。</p>
<p>Java Runtime Environment(JRE)包含：Java虚拟机、库函数、运行Java应用程序所必须的文件。</p>
<p>Java Development Kit(JDK)包含JRE，以及增加编译器和调试器等用于程序开发的文件。</p>
<p>包含关系：JDK&gt;JRE&gt;JVM </p>
<p>JDK下载和安装</p>
<p>1.下载JDK（对应系统版本）</p>
<p>2.简单目录说明（bin、lib、src.zip）</p>
<p>JDK环境变量PATH设置</p>
<p>1.配置JAVA_HOME</p>
<p>2.Windows配置Path（%JAVA_HOME%\bin;）</p>
<p>Mac</p>
<p>vim ~/.bash_profile 配置JDK地址</p>
<h2 id="控制台测试JDK安装和配置"><a href="#控制台测试JDK安装和配置" class="headerlink" title="控制台测试JDK安装和配置"></a>控制台测试JDK安装和配置</h2><p>Windows: cmd 输入 java-version</p>
<h2 id="写出第一个Java程序"><a href="#写出第一个Java程序" class="headerlink" title="写出第一个Java程序"></a>写出第一个Java程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Welcome</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello word!&quot;</span>)；</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释并运行：<code>java Welcome</code></p>
<h2 id="第一个Java程序详细解析"><a href="#第一个Java程序详细解析" class="headerlink" title="第一个Java程序详细解析"></a>第一个Java程序详细解析</h2><p>1.Java大小写敏感的语言；</p>
<p>2.一个源文件中至多只能声明一个public的类，其他类的个数不限。</p>
<h2 id="最常用的DOS命令"><a href="#最常用的DOS命令" class="headerlink" title="最常用的DOS命令"></a>最常用的DOS命令</h2><p>1.cd 目录路径 进入一个目录</p>
<p>2.cd .. 进入父目录</p>
<p>3.dir 查看本目录下的文件和子目录列表</p>
<p>4.cls 清楚屏幕命令</p>
<p>5.上下键 查找敲过的命令</p>
<p>6.Tab键 自动补齐命令</p>
<h2 id="常用开发工具介绍"><a href="#常用开发工具介绍" class="headerlink" title="常用开发工具介绍"></a>常用开发工具介绍</h2><p>eclipse</p>
<p>IntelliJ IDE</p>
<p>NetBeans</p>
<h2 id="eclipse下载版本选择和使用"><a href="#eclipse下载版本选择和使用" class="headerlink" title="eclipse下载版本选择和使用"></a>eclipse下载版本选择和使用</h2><p>Eclipse IDE for Java Developers（根据安装的JDK）</p>
<p>eclipse下建立Java项目</p>
<p>目录结构（src、bin、JRE）</p>
<p>eclipse开发和运行Java程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Welcome Java&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释： //</p>
<p>多行注释：<code> 以/*开头，以*/结尾</code></p>
<p>文档注释：<code> 以/**开头，以*/结尾</code></p>
<h2 id="标识符规则"><a href="#标识符规则" class="headerlink" title="标识符规则"></a>标识符规则</h2><p>1.以字母、下划线、美元符号开头$开头，其他部分是字母、下划线、$、数字的任意组合；</p>
<p>2.Java标识符大小写敏感，且长度无限制；</p>
<p>3.标识符不可以是Java的关键字；</p>
<p>4.类名首字母大写，方法和变量的标识符遵循驼峰命名原则；</p>
<h2 id="Java的关键字-保留字"><a href="#Java的关键字-保留字" class="headerlink" title="Java的关键字/保留字"></a>Java的关键字/保留字</h2><p>边用边学边记</p>
<p>##变量的本质</p>
<p>变量=可操作的存储空间；通过变量名来访问对应的存储空间，从而操作这个存储空间的值；</p>
<h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><p>局部变量（local variable）方法或语句块内部定义的变量。生命周期是从声名位置开始到方法或语句块执行完毕为止；必须进行初始化操作；</p>
<p>成员变量/实例变量（member variable）方法外部、类的内部定义的变量。从属于对象，生命周期伴随对象始终；可以默认初始化；</p>
<p>静态变量/类变量（static variable）使用static定义，从属于类，生命周期伴随类始终，从类加载到卸载。</p>
<h2 id="常量（Constant）和final"><a href="#常量（Constant）和final" class="headerlink" title="常量（Constant）和final"></a>常量（Constant）和final</h2><p>常量通常指的是一个固定值，使用final来定义一个常量，一旦被初始化以后就不能再修改；</p>
<p>变量和常量命令规范，见名知意；</p>
<p>常量命名采用大写字母和下划线的方式；</p>
<p>方法名：首字母小写和驼峰原则；</p>
<h2 id="基本类型数据介绍"><a href="#基本类型数据介绍" class="headerlink" title="基本类型数据介绍"></a>基本类型数据介绍</h2><p>数值型-byte、short、int、long、float、double</p>
<p>字符型（文本型）-char</p>
<p>布尔型-boolean</p>
<h2 id="整型变量和整型常量"><a href="#整型变量和整型常量" class="headerlink" title="整型变量和整型常量"></a>整型变量和整型常量</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1字节</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4字节</td>
</tr>
<tr>
<td align="center">Long</td>
<td align="center">8字节</td>
</tr>
</tbody></table>
<p>八进制，以0开头；</p>
<p>十六进制，以0x或0X开头；</p>
<p>二进制，以0b或0B开头；</p>
<h2 id="浮点型变量和BigDecimal的使用"><a href="#浮点型变量和BigDecimal的使用" class="headerlink" title="浮点型变量和BigDecimal的使用"></a>浮点型变量和BigDecimal的使用</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">4字节</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8字节</td>
</tr>
</tbody></table>
<p>科学记数形式，314e2(3.14)、314E2（314.0）；</p>
<p>java.math包下两个类：BigInteger和BigDecimal可以处理任意长度的数值；</p>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Char</td>
<td align="center">2个字节</td>
</tr>
</tbody></table>
<p>Unicode编码，允许有65536个字符；也可以采用十六进制的值表示；</p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
<th align="center">Unicode值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\b</td>
<td align="center">推格(backspace)</td>
<td align="center">\u0008</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行</td>
<td align="center">\u000a</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车</td>
<td align="center">\u000d</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表符(tab)</td>
<td align="center">\u0009</td>
</tr>
<tr>
<td align="center">\ “</td>
<td align="center">双引号</td>
<td align="center">\u0022</td>
</tr>
<tr>
<td align="center">\ ‘</td>
<td align="center">单引号</td>
<td align="center">\u0027</td>
</tr>
<tr>
<td align="center">\ \</td>
<td align="center">反斜杠</td>
<td align="center">\u005c</td>
</tr>
</tbody></table>
<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>boolean类型有两个常量值，true和false，在内存中占一位；</p>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p><code>+ - * / % 二元运算符</code></p>
<p><code> ++、-- 一元运算符</code> </p>
<h2 id="赋值及其扩展运算符"><a href="#赋值及其扩展运算符" class="headerlink" title="赋值及其扩展运算符"></a>赋值及其扩展运算符</h2><p><code> 运算符 +=、-=、*=、/=、%=</code></p>
<p>关系运算符</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于或等于</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于或等于</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑与 &amp;</td>
<td align="center">两个都为true,结果为true</td>
</tr>
<tr>
<td align="center">逻辑或|</td>
<td align="center">两个有一个为true，结果为true</td>
</tr>
<tr>
<td align="center">短路与&amp;&amp;</td>
<td align="center">只要有一个为false，结果为false</td>
</tr>
<tr>
<td align="center">短路或||</td>
<td align="center">只要有一个为true，结果直接为true</td>
</tr>
<tr>
<td align="center">逻辑非!</td>
<td align="center">取反</td>
</tr>
<tr>
<td align="center">逻辑异或^</td>
<td align="center">相同为false，不同为true</td>
</tr>
</tbody></table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>二进制位的运算；</p>
<table>
<thead>
<tr>
<th align="center">位运算符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">～</td>
<td align="center">取反</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center">｜</td>
<td align="center">按位或</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移运算符，左移1位相当于乘2</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移运算符，右移1位相当于除2取商</td>
</tr>
</tbody></table>
<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p><code>字符串连接符+</code>；</p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p><code>X？Y：Z</code></p>
<p>其中 x 为 boolean 类型表达式，先计算 x 的值，若为true，则整个运算的结果为表达式 y 的值，否则整个运算结果为表达式 z 的值。</p>
<p>2020年12月</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="/images/yxj.png" alt="yxj"></p>
<p>逻辑非&gt;逻辑与&gt;逻辑或</p>
<p>自动类型转化</p>
<p>自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。</p>
<p><img src="/images/zh.png" alt="yxj"></p>
<p>强制类型转化</p>
<p>强制类型转换，又被称为造型，用于显式的转换一个数值的类型。在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。</p>
<p><code> (type) var</code></p>
<p>运算符“()”中的type表示将值var想要转换成的目标数据类型。当将一种类型强制转换成另一种类型，而又超出了目标类型的表数范围，就会被截断成为一个完全不同的值。</p>
<p>基本类型常见错误</p>
<p>操作比较大的数时，要留意是否溢出，尤其是整数操作时。</p>
<p>L和l 的问题：不要命名名字为l的变量，l容易和1混淆。</p>
<h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String name=scanner.nextLine();</span><br></pre></td></tr></table></figure>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="控制语句-1"><a href="#控制语句-1" class="headerlink" title="控制语句"></a>控制语句</h2><p>“顺序结构”代表“先执行a，再执行b”的逻辑。</p>
<p>“选择结构”代表“如果…，则…”的逻辑。</p>
<p>“循环结构”代表“如果…，则再继续…”的逻辑。</p>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><ol>
<li><p>if单选择结构</p>
</li>
<li><p>if-else双选择结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">	语句<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if-else if-else多选择结构</p>
</li>
<li><p>switch结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">1</span>: </span><br><span class="line">语句序列<span class="number">1</span>;</span><br><span class="line">[<span class="keyword">break</span>];</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line"> 语句序列<span class="number">2</span>;</span><br><span class="line">[<span class="keyword">break</span>];</span><br><span class="line">     … … …      … …</span><br><span class="line">[<span class="keyword">default</span>:</span><br><span class="line"> 默认语句;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p> 循环结构分两大类，一类是当型，一类是直到型。</p>
<p>while循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (布尔表达式) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do-while循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        循环体;</span><br><span class="line">     &#125; <span class="keyword">while</span>(布尔表达式) ;</span><br></pre></td></tr></table></figure>

<p>for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始表达式; 布尔表达式; 迭代因子) &#123;</span><br><span class="line">      循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。</p>
<p>2.continue用在for循环中，跳到for循环的迭代因子部分。</p>
<p>3.在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符<span class="number">1</span>  修饰符<span class="number">2</span>  …]   返回值类型    方法名(形式参数列表)&#123;</span><br><span class="line">    Java语句；… … …</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对象名.方法名(实参列表)</p>
<p>   方法的详细说明</p>
<ol>
<li><p>形式参数：在方法声明时用于接收外界传入的数据。</p>
</li>
<li><p>实参：调用方法时实际传给方法的数据。</p>
</li>
<li><p>返回值：方法在执行完毕后返还给调用它的环境的数据。</p>
</li>
<li><p>返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void。</p>
</li>
</ol>
<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象　"></a>类和对象　</h2><p><strong>类：</strong>我们叫做class。 <strong>对象：</strong>我们叫做Object,instance(实例)。以后我们说某个类的对象，某个类的实例。是一样的意思</p>
<p>1.对象是具体的事物;类是对对象的抽象;</p>
<p>2.类可以看成一类对象的模板，对象可以看成该类的一个具体实例。</p>
<p>3.类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每一个源文件必须有且只有一个public class，并且类名和文件名保持一致！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tyre</span> </span>&#123; <span class="comment">// 一个Java文件可以同时定义多个class</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seat</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。这三种成员都可以定义零个或多个。</p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符]  方法返回值类型  方法名(形参列表) &#123;</span><br><span class="line">    <span class="comment">// n条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 类名(形参列表)&#123;</span><br><span class="line">    <span class="comment">//n条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过new关键字调用!!</p>
</li>
<li><p>构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。</p>
</li>
<li><p>如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!</p>
</li>
<li><p>构造器的方法名必须和类名一致!</p>
</li>
</ol>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>创建大量无用对象</strong></p>
<p><strong>静态集合类的使用</strong></p>
<p><strong>各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭</strong></p>
<p><strong>监听器的使用</strong></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步：</p>
<p>　　1. 分配对象空间，并将对象成员变量初始化为0或空</p>
<p>　　2. 执行属性值的显示初始化</p>
<p>　　3. 执行构造方法</p>
<p>　　4. 返回对象的地址给相关的变量</p>
<p>　　this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象” 。</p>
<p>在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点：</p>
<p>　　1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。</p>
<p>　　2. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!!</p>
<p>　　3. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)</p>
<p>　　4. 在static方法中不可直接访问非static的成员。</p>
<h2 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h2><p>构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员。</p>
<h2 id="参数传值的机制"><a href="#参数传值的机制" class="headerlink" title="参数传值的机制"></a>参数传值的机制</h2><p>Java中，方法中所有参数都是“值传递”，也就是“传递的是值的副本”。 也就是说，我们得到的是“原参数的复印件，而不是原件”。因此，复印件改变不会影响原件。</p>
<h2 id="package-import"><a href="#package-import" class="headerlink" title="package\import"></a>package\import</h2><p>　1. 通常是类的第一句非注释性语句。</p>
<p>　2. 包名：域名倒着写即可，再加上模块名，便于内部管理类。</p>
<p>JDK主要包：java.lang;java.awt;java.net;java.io;java.util;</p>
<p>如果我们要使用其他包的类，需要使用import导入，从而可以在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。import后，便于编写代码，提高可维护性。</p>
<h1 id="Java面向对象特征"><a href="#Java面向对象特征" class="headerlink" title="Java面向对象特征"></a>Java面向对象特征</h1><h2 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承(extends)"></a>继承(extends)</h2><p>1.继承让我们更加容易实现类的扩展。 比如，我们定义了人类，再定义Boy类就只需要扩展人类即可。实现了代码的重用，不用再重新发明轮子(don’t  reinvent  wheels)。从英文字面意思理解，extends的意思是“扩展”。子类是父类的扩展。现实世界中的继承无处不在。</p>
<p>2.instanceof是二元运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。</p>
<p>1.父类也称作超类、基类、派生类等。</p>
<p>2.Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。</p>
<p>3.Java中类没有多继承，接口有多继承。</p>
<p>4.子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。</p>
<p>5.如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。</p>
<h2 id="方法重写-override"><a href="#方法重写-override" class="headerlink" title="方法重写(override)"></a>方法重写(override)</h2><p>子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。</p>
<p><strong>方法的重写需要符合下面的三个要点：</strong></p>
<p>   1.“==”： 方法名、形参列表相同。</p>
<p>   2.“≤”：返回值类型和声明异常类型，子类小于等于父类。</p>
<p>   3.“≥”： 访问权限，子类大于等于父类。</p>
<p>Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。</p>
<p>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。</p>
<p>   使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。</p>
<p>   若是构造方法的第一行代码没有显式的调用super(…)或者this(…);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>优点：</strong></p>
<ol>
<li><p>提高代码的安全性。</p>
</li>
<li><p>提高代码的复用性。</p>
</li>
<li><p>“高内聚”：封装细节，便于修改内部代码，提高可维护性。</p>
</li>
<li><p>“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>同一个类</th>
<th>同一个包中</th>
<th>子类</th>
<th align="center">所有类</th>
</tr>
</thead>
<tbody><tr>
<td>Private</td>
<td>*</td>
<td></td>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td>Default</td>
<td>*</td>
<td>*</td>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td>Protected</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td align="center"></td>
</tr>
<tr>
<td>Public</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td align="center">*</td>
</tr>
</tbody></table>
</li>
<li><p>private 表示私有，只有自己类能访问</p>
</li>
<li><p>default表示没有修饰符修饰，只有同一个包的类能访问</p>
</li>
<li><p>protected表示可以被同一个包的类以及其他包中的子类访问</p>
</li>
<li><p>public表示可以被该项目的所有包中的所有类访问</p>
</li>
</ol>
<p><strong>类属性的处理：</strong></p>
<p>1.一般使用private访问权限。</p>
<p>2.提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。</p>
<p>3.一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的要点：</p>
<ol>
<li><p>多态是方法的多态，不是属性的多态(多态与属性无关)。</p>
</li>
<li><p>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</p>
</li>
<li><p>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</p>
</li>
</ol>
<p>父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。</p>
<p>   向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型!</p>
<p><strong>·抽象方法</strong></p>
<p>   使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。</p>
<p><strong>·抽象类</strong></p>
<p>   包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符]  interface 接口名   [extends  父接口1，父接口2…]  &#123;</span><br><span class="line">常量定义；  </span><br><span class="line">方法定义；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义接口的详细说明：</strong></p>
<ol>
<li><p>访问修饰符：只能是public或默认。</p>
</li>
<li><p>接口名：和类名采用相同命名机制。</p>
</li>
<li><p>extends：接口可以多继承。</p>
</li>
<li><p>常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。</p>
</li>
<li><p>方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract。</p>
</li>
</ol>
<p><strong>要点</strong></p>
<ol>
<li><p>子类通过implements来实现接口中的规范。</p>
</li>
<li><p>接口不能创建实例，但是可用于声明引用变量类型。</p>
</li>
<li><p>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。</p>
</li>
<li><p>JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。</p>
</li>
<li><p>JDK1.8后，接口中包含普通的静态方法。</p>
</li>
</ol>
<h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><p><strong>异常机制本质</strong></p>
<p>   就是当程序出现错误，程序安全退出的机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//语句块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理过程：</strong></p>
<ol>
<li><p><strong>抛出异常：</strong>在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。</p>
</li>
<li><p><strong>捕获异常：</strong>JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。</p>
<p>Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception。</p>
</li>
</ol>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Error是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM(Java 虚拟机)出现的问题。例如，Java虚拟机运行错误(Virtual MachineError)，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。</p>
<p>   Error表明系统JVM已经处于不可恢复的崩溃状态中。我们不需要管它。</p>
<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>Exception是程序本身能够处理的异常，如：空指针异常(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常(ArithmeticException)等。</p>
<p>   Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为：</p>
<ol>
<li><p>RuntimeException 运行时异常</p>
</li>
<li><p>CheckedException 已检查异常</p>
<p>派生于RuntimeException的异常，如被 0 除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。 因此由系统自动检测并将它们交给缺省的异常处理程序(用户可不必对其处理)。</p>
<p>这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,经常需要通过增加“逻辑处理来避免这些异常”。</p>
</li>
</ol>
<p>所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理，否则无法通过编译。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>捕获异常是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行(catch语句可有多条;finally语句最多只能有一条，根据自己的需要可有可无)。</p>
<p>当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。</p>
<p>   在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。</p>
<p>   如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。</p>
<p>   如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组的三个基本特点：</p>
<ol>
<li><p>长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</p>
</li>
<li><p>其元素必须是相同类型，不允许出现混合类型。</p>
</li>
<li><p>数组类型可以是任何数据类型，包括基本类型和引用类型。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type[]  arr_name; ``<span class="comment">//（推荐使用这种方式）</span></span><br><span class="line">type  arr_name[];</span><br></pre></td></tr></table></figure>

<p>数组的初始化方式总共有三种：静态初始化、动态初始化、默认初始化。</p>
<p>增强for循环for-each是JDK1.5新增加的功能，专门用于读取数组或集合中所有的元素，即对数组进行遍历。</p>
<p><strong>注意事项</strong></p>
<ol>
<li><p>for-each增强for循环在遍历数组过程中不能修改数组中某元素的值。</p>
</li>
<li><p>for-each仅适用于遍历，不涉及有关索引(下标)的操作。</p>
</li>
</ol>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><p>基本数据类型对应的包装类</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>在这八个类中，除了Character和Boolean以外，其他的都是“数字型”，“数字型”都是java.lang.Number的子类。Number类是抽象类，因此它的抽象方法，所有子类都需要提供实现。Number类提供了抽象方法：intValue()、longValue()、floatValue()、doubleValue()，意味着所有的“数字型”包装类都可以互相转型。</p>
<h2 id="String类、StringBuffer和StringBuilder"><a href="#String类、StringBuffer和StringBuilder" class="headerlink" title="String类、StringBuffer和StringBuilder"></a>String类、StringBuffer和StringBuilder</h2><ol>
<li><p>String类的下述方法能创建并返回一个新的String对象: concat()、 replace()、substring()、 toLowerCase()、 toUpperCase()、trim()。</p>
</li>
<li><p>提供查找功能的有关方法: endsWith()、 startsWith()、 indexOf()、lastIndexOf()。</p>
</li>
<li><p>提供比较功能的方法: equals()、equalsIgnoreCase()、compareTo()。</p>
</li>
<li><p>其它方法: charAt() 、length()。</p>
<p>StringBuffer和StringBuilder非常类似，均代表可变的字符序列。 这两个类都是抽象类AbstractStringBuilder的子类，方法几乎一模一样。</p>
</li>
<li><p>重载的public StringBuilder append(…)方法</p>
</li>
</ol>
<p>​    可以为该StringBuilder 对象添加字符序列，仍然返回自身对象。</p>
<ol start="2">
<li>方法 public StringBuilder delete(int start,int end)</li>
</ol>
<p>​    可以删除从start开始到end-1为止的一段字符序列，仍然返回自身对象。</p>
<ol start="3">
<li>方法 public StringBuilder deleteCharAt(int index)</li>
</ol>
<p>​    移除此序列指定位置上的 char，仍然返回自身对象。</p>
<ol start="4">
<li>重载的public StringBuilder insert(…)方法</li>
</ol>
<p>​    可以为该StringBuilder 对象在指定位置插入字符序列，仍然返回自身对象。</p>
<ol start="5">
<li>方法 public StringBuilder reverse()</li>
</ol>
<p>​    用于将字符序列逆序，仍然返回自身对象。</p>
<ol start="6">
<li><p>方法 public String toString() 返回此序列中数据的字符串表示形式。</p>
</li>
<li><p>和 String 类含义类似的方法：</p>
</li>
</ol>
<p><strong>要点：</strong></p>
<ol>
<li><p>String：不可变字符序列。</p>
</li>
<li><p>StringBuffer：可变字符序列，并且线程安全，但是效率低。</p>
</li>
<li><p>StringBuilder：可变字符序列，线程不安全，但是效率高(一般用它)。</p>
</li>
</ol>
<h2 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h2><p>在标准Java类库中包含一个Date类。它的对象表示一个特定的瞬间，精确到毫秒。</p>
<ol>
<li><p>Date() 分配一个Date对象，并初始化此对象为系统当前的日期和时间，可以精确到毫秒)。</p>
</li>
<li><p>Date(long date) 分配 Date 对象并初始化此对象，以表示自从标准基准时间(称为“历元(epoch)”，即 1970 年 1 月 1 日 00:00:00 GMT)以来的指定毫秒数。</p>
</li>
<li><p>boolean after(Date when) 测试此日期是否在指定日期之后。</p>
</li>
<li><p>booleanbefore(Date when) 测试此日期是否在指定日期之前。</p>
</li>
<li><p>boolean equals(Object obj) 比较两个日期的相等性。</p>
</li>
<li><p>long getTime() 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p>
</li>
<li><p>String toString() 把此 Date 对象转换为以下形式的 String：</p>
</li>
</ol>
<p>​    dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun、 Mon、Tue、Wed、 Thu、 Fri、 Sat)。</p>
<p><strong>·DateFormat类的作用</strong></p>
<p>   把时间对象转化成指定格式的字符串。反之，把指定格式的字符串转化成时间对象。</p>
<p>   DateFormat是一个抽象类，一般使用它的的子类SimpleDateFormat类来实现。</p>
<p>Calendar 类是一个抽象类，为我们提供了关于日期计算的相关功能，比如：年、月、日、时、分、秒的展示和计算。</p>
<p>   GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算;其方法的参数和返回值类型一般为double型。如果需要更加强大的数学运算能力，计算高等数学中的相关内容，可以使用apache commons下面的Math类库。</p>
<p><strong>Math类的常用方法：</strong></p>
<ol>
<li><p>abs 绝对值</p>
</li>
<li><p>acos,asin,atan,cos,sin,tan 三角函数</p>
</li>
<li><p>sqrt 平方根</p>
</li>
<li><p>pow(double a, double b) a的b次幂</p>
</li>
<li><p>max(double a, double b) 取大值</p>
</li>
<li><p>min(double a, double b) 取小值</p>
</li>
<li><p>ceil(double a) 大于a的最小整数</p>
</li>
<li><p>floor(double a) 小于a的最大整数</p>
</li>
<li><p>random() 返回 0.0 到 1.0 的随机数</p>
</li>
<li><p>long round(double a) double型的数据a转换为long型(四舍五入)</p>
</li>
<li><p>toDegrees(double angrad) 弧度-&gt;角度</p>
</li>
<li><p>toRadians(double angdeg) 角度-&gt;弧度</p>
</li>
</ol>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p> java.io.File类：代表文件和目录。 在开发中，读取文件、生成文件、删除文件、修改文件的属性时经常会用到本类。</p>
<p><strong>File类的常见构造方法：public File(String pathname)</strong></p>
<p>   以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</p>
<p><strong>通过File对象可以访问文件的属性：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean exists()</td>
<td>判断File是否存在</td>
</tr>
<tr>
<td>public boolean isDiretory()</td>
<td>判断File是否是目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>判断File是否是文件</td>
</tr>
<tr>
<td>public long lastModified()</td>
<td>返回File最后修改时间</td>
</tr>
<tr>
<td>public long length()</td>
<td>返回File大小</td>
</tr>
<tr>
<td>public String getName()</td>
<td>返回文件名</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>返回文件的目录路径</td>
</tr>
</tbody></table>
<p><strong>通过File对象创建空文件或目录(在该对象所指的文件或目录不存在的情况下)</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>createNewFile()</td>
<td>创建新的File</td>
</tr>
<tr>
<td>delete()</td>
<td>删除File对应的文件</td>
</tr>
<tr>
<td>mkdir()</td>
<td>创建一个目录；中间某个目录缺失，则创建失败</td>
</tr>
<tr>
<td>mkdirs()</td>
<td>创建多个目录，中间某个目录缺失，则创建该缺失目录</td>
</tr>
</tbody></table>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型的定义包括枚举声明和枚举体。格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>` `枚举名 </span>&#123;``   ``枚举体（常量列表）``&#125;</span><br></pre></td></tr></table></figure>

<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection 表示一组对象，它是集中、收集的意思。Collection接口的两个子接口是List、Set接口。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(Object element)</td>
<td>增加元素到容器中</td>
</tr>
<tr>
<td>Boolean remove(Object element)</td>
<td>从容器中移除元素</td>
</tr>
<tr>
<td>Boolean contains(Object element)</td>
<td>容器中是否包含该元素</td>
</tr>
<tr>
<td>int size()</td>
<td>容器中元素的数量</td>
</tr>
<tr>
<td>Boolean isEmpty()</td>
<td>容器是否为空</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空容器中所有元素</td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>获得迭代器，用于遍历所有元素</td>
</tr>
<tr>
<td>Boolean containsAll(Collection c)</td>
<td>本容器是否包含C容器中的所有元素</td>
</tr>
<tr>
<td>Boolean addAll(Collection c)</td>
<td>将容器C中所有元素增加到本容器中</td>
</tr>
<tr>
<td>Boolean removeAll(Collection c)</td>
<td>移除本容器和容器C都包含的元素</td>
</tr>
<tr>
<td>boolean retainAll(Collection c)</td>
<td>取本容器和容器C中都包含的元素，移除非交集元素</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>转化成Object数组</td>
</tr>
</tbody></table>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List是有序、可重复的容器。</p>
<p>   <strong>有序：</strong>List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。</p>
<p>   <strong>可重复：</strong>List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index,Object element)</td>
<td>在指定位置插入元素，以前元素全部后移一位</td>
</tr>
<tr>
<td>Object set(int index,Object element)</td>
<td>修改指定位置的元素</td>
</tr>
<tr>
<td>Object get(int index)</td>
<td>返回指定位置的元素</td>
</tr>
<tr>
<td>Object remove(int index)</td>
<td>删除指定位置的元素，后面元素全部移一位</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td>返回第一个匹配元素的索引，如果没有该元素，返回-1</td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td>返回最后一个匹配元素的索引，如果没有该元素，返回-1</td>
</tr>
</tbody></table>
<p>List接口常用的实现类有3个：ArrayList、LinkedList和Vector。</p>
<h2 id="ArrayList、LinkedList、Vector"><a href="#ArrayList、LinkedList、Vector" class="headerlink" title="ArrayList、LinkedList、Vector"></a>ArrayList、LinkedList、<strong>Vector</strong></h2><p>ArrayList底层是用数组实现的存储。 特点：查询效率高，增删效率低，线程不安全。我们一般使用它。</p>
<p> LinkedList底层用双向链表实现的存储。特点：查询效率低，增删效率高，线程不安全。</p>
<p>   双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前一个节点和后一个节点。 所以，从双向链表中的任意一个节点开始，都可以很方便地找到所有节点。</p>
<p>Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。 比如，indexOf方法就增加了synchronized同步标记。</p>
<h2 id="Map、HashMap、HashTable"><a href="#Map、HashMap、HashTable" class="headerlink" title="Map、HashMap、HashTable"></a>Map、HashMap、HashTable</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object put(Object key,Object value)</td>
<td>存放键值对</td>
</tr>
<tr>
<td>Object get(Object key)</td>
<td>通过键对象查找得到值对象</td>
</tr>
<tr>
<td>Object remove(Object key)</td>
<td>删除键对象对应的键值对</td>
</tr>
<tr>
<td>Boolean containKey(Object key)</td>
<td>Map容器中是否包含键对象对应的键值对</td>
</tr>
<tr>
<td>Boolean containValue(Object key)</td>
<td>Map容器中是否包含值对象对应的键值对</td>
</tr>
<tr>
<td>int size()</td>
<td>包含键值对的数量</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>Map是否为空</td>
</tr>
<tr>
<td>void putAll(Map t)</td>
<td>将t的所有键值对存放到本map对象</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空map对象所有键值对</td>
</tr>
</tbody></table>
<p>HashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。 HashMap在查找、删除、修改方面都有非常高的效率。</p>
<p><strong>HashMap与HashTable的区别</strong></p>
<ol>
<li><p>HashMap: 线程不安全，效率高。允许key或value为null。</p>
</li>
<li><p>HashTable: 线程安全，效率低。不允许key或value为null。</p>
</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p> Set容器特点：无序、不可重复。无序指Set中的元素没有索引，我们只能遍历查找;不可重复指不允许加入重复的元素。更确切地讲，新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入;甚至，Set中也只能放入一个null元素，不能多个。</p>
<p>   Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet。</p>
<h2 id="Collections工具"><a href="#Collections工具" class="headerlink" title="Collections工具"></a>Collections工具</h2><p>类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。</p>
<ol>
<li><p>void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。</p>
</li>
<li><p>void shuffle(List) //对List容器内的元素进行随机排列。</p>
</li>
<li><p>void reverse(List) //对List容器内的元素进行逆续排列 。</p>
</li>
<li><p>void fill(List, Object) //用一个特定的对象重写整个List容器。</p>
</li>
<li><p>int binarySearch(List, Object)//对于顺序的List容器，采用折半查找的方法查找特定对象。</p>
</li>
</ol>
<h1 id="IO技术"><a href="#IO技术" class="headerlink" title="IO技术"></a>IO技术</h1><p>数据源data source，提供数据的原始媒介。常见的数据源有：数据库、文件、其他程序、内存、网络连接、IO设备。</p>
<p>   数据源分为：源设备、目标设备。</p>
<ol>
<li><p>源设备：为程序提供数据，一般对应输入流。</p>
</li>
<li><p>目标设备：程序数据的目的地，一般对应输出流。</p>
</li>
</ol>
<p>流是一个抽象、动态的概念，是一连串连续动态的数据集合。</p>
<p>   对于输入流而言，数据源就像水箱，流(stream)就像水管中流动着的水流，程序就是我们最终的用户。我们通过流(A Stream)将数据源(Source)中的数据(information)输送到程序(Program)中。</p>
<p>   对于输出流而言，目标数据源就是目的地(dest)，我们通过流(A Stream)将程序(Program)中的数据(information)输送到目的数据源(dest)中。</p>
<p>  输入/输出流的划分是相对程序而言的，并不是相对数据源。</p>
<h2 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h2><p><strong>按流的方向分类：</strong></p>
<ol>
<li><p>输入流：数据流向是数据源到程序(以InputStream、Reader结尾的流)。</p>
</li>
<li><p>输出流：数据流向是程序到目的地(以OutPutStream、Writer结尾的流)。</p>
</li>
</ol>
<p><strong>按处理的数据单元分类：</strong></p>
<ol>
<li><p>字节流：以字节为单位获取数据，命名上以Stream结尾的流一般是字节流，如FileInputStream、FileOutputStream。</p>
</li>
<li><p>字符流：以字符为单位获取数据，命名上以Reader/Writer结尾的流一般是字符流，如FileReader、FileWriter。</p>
</li>
</ol>
<p><strong>按处理对象不同分类：</strong></p>
<ol>
<li><p>节点流：可以直接从数据源或目的地读写数据，如FileInputStream、FileReader、DataInputStream等。</p>
</li>
<li><p>处理流：不直接连接到数据源或目的地，是”处理流的流”。通过对其他流的处理提高程序的性能，如BufferedInputStream、BufferedReader等。处理流也叫包装流。</p>
<p>节点流处于IO操作的第一线，所有操作必须通过它们进行;处理流可以对节点流进行包装，提高性能或提高程序的灵活性。</p>
</li>
</ol>
<p>从上图发现，很多流都是成对出现的，比如：FileInputStream/FileOutputStream，显然是对文件做输入和输出操作的。我们下面简单做个总结：</p>
<ol>
<li>InputStream/OutputStream</li>
</ol>
<p>​    字节流的抽象类。</p>
<ol start="2">
<li>Reader/Writer</li>
</ol>
<p>​    字符流的抽象类。</p>
<ol start="3">
<li>FileInputStream/FileOutputStream</li>
</ol>
<p>​    节点流：以字节为单位直接操作“文件”。</p>
<ol start="4">
<li>ByteArrayInputStream/ByteArrayOutputStream</li>
</ol>
<p>​    节点流：以字节为单位直接操作“字节数组对象”。</p>
<ol start="5">
<li>ObjectInputStream/ObjectOutputStream</li>
</ol>
<p>​    处理流：以字节为单位直接操作“对象”。</p>
<ol start="6">
<li>DataInputStream/DataOutputStream</li>
</ol>
<p>​    处理流：以字节为单位直接操作“基本数据类型与字符串类型”。</p>
<ol start="7">
<li>FileReader/FileWriter</li>
</ol>
<p>​    节点流：以字符为单位直接操作“文本文件”(注意：只能读写文本文件)。</p>
<ol start="8">
<li>BufferedReader/BufferedWriter</li>
</ol>
<p>​    处理流：将Reader/Writer对象进行包装，增加缓存功能，提高读写效率。</p>
<ol start="9">
<li>BufferedInputStream/BufferedOutputStream</li>
</ol>
<p>​    处理流：将InputStream/OutputStream对象进行包装，增加缓存功能，提高 读写效率。</p>
<ol start="10">
<li>InputStreamReader/OutputStreamWriter</li>
</ol>
<p>​    处理流：将字节流对象转化成字符流对象。</p>
<ol start="11">
<li>PrintStream</li>
</ol>
<p>​    处理流：将OutputStream进行包装，可以方便地输出字符，更加灵活。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>当两个进程远程通信时，彼此可以发送各种类型的数据。 无论是何种类型的数据，都会以二进制序列的形式在网络上传送。比如，我们可以通过http协议发送字符串信息;我们也可以在网络上直接发送Java对象。发送方需要把这个Java对象转换为字节序列，才能在网络上传送;接收方则需要把字节序列再恢复为Java对象才能正常读取。</p>
<p>   把Java对象转换为字节序列的过程称为对象的序列化。把字节序列恢复为Java对象的过程称为对象的反序列化。</p>
<p>   对象序列化的作用有如下两种：</p>
<ol>
<li><p>持久化： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中，比如：休眠的实现。以后服务器session管理，hibernate将对象持久化实现。</p>
</li>
<li><p>网络通信：在网络上传送对象的字节序列。比如：服务器之间的数据通信、对象传递。</p>
</li>
</ol>
<p>ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p>
<p>   ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</p>
<p>   只有实现了Serializable接口的类的对象才能被序列化。 Serializable接口是一个空接口，只起到标记作用。</p>
<h2 id="装饰类Apache-IOUtils和FileUtils的使用"><a href="#装饰类Apache-IOUtils和FileUtils的使用" class="headerlink" title="装饰类Apache IOUtils和FileUtils的使用"></a>装饰类<strong>Apache IOUtils和FileUtils的使用</strong></h2><p><strong>FieUtils类中常用方法的介绍</strong></p>
<p>   打开FileUtils的api文档，我们抽出一些工作中比较常用的方法，进行总结和讲解。总结如下：</p>
<p>   cleanDirectory：清空目录，但不删除目录。</p>
<p>   contentEquals：比较两个文件的内容是否相同。</p>
<p>   copyDirectory：将一个目录内容拷贝到另一个目录。可以通过FileFilter过滤需要拷贝的 文件。</p>
<p>   copyFile：将一个文件拷贝到一个新的地址。</p>
<p>   copyFileToDirectory：将一个文件拷贝到某个目录下。</p>
<p>   copyInputStreamToFile：将一个输入流中的内容拷贝到某个文件。</p>
<p>   deleteDirectory：删除目录。</p>
<p>   deleteQuietly：删除文件。</p>
<p>   listFiles：列出指定目录下的所有文件。</p>
<p>   openInputSteam：打开指定文件的输入流。</p>
<p>   readFileToString：将文件内容作为字符串返回。</p>
<p>   readLines：将文件内容按行返回到一个字符串数组中。</p>
<p>   size：返回文件或目录的大小。</p>
<p>   write：将字符串内容直接写到文件中。</p>
<p>   writeByteArrayToFile:将字节数组内容写到文件中。</p>
<p>   writeLines：将容器中的元素的toString方法返回的内容依次写入文件中。</p>
<p>   writeStringToFile：将字符串内容写到文件中。</p>
<p><strong>IOUtils类中常用方法的介绍</strong></p>
<p>   buffer方法：将传入的流进行包装，变成缓冲流。并可以通过参数指定缓冲大小。</p>
<p>   closeQueitly方法：关闭流。</p>
<p>   contentEquals方法：比较两个流中的内容是否一致。</p>
<p>   copy方法：将输入流中的内容拷贝到输出流中，并可以指定字符编码。</p>
<p>   copyLarge方法：将输入流中的内容拷贝到输出流中，适合大于2G内容的拷贝。</p>
<p>   lineIterator方法：返回可以迭代每一行内容的迭代器。</p>
<p>   read方法：将输入流中的部分内容读入到字节数组中。</p>
<p>   readFully方法：将输入流中的所有内容读入到字节数组中。</p>
<p>   readLine方法：读入输入流内容中的一行。</p>
<p>   toBufferedInputStream，toBufferedReader：将输入转为带缓存的输入流。</p>
<p>   toByteArray，toCharArray：将输入流的内容转为字节数组、字符数组。</p>
<p>   toString：将输入流或数组中的内容转化为字符串。</p>
<p>   write方法：向流里面写入内容。</p>
<p>   writeLine方法：向流里面写入一行内容。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p> “程序(Program)”是一个静态的概念，一般对应于操作系统中的一个可执行文件。</p>
<p> 执行中的程序叫做进程(Process)，是一个动态的概念。现代的操作系统都可以同时启动多个进程。</p>
<p>一个进程可以产生多个线程。同多个进程可以共享操作系统的某些资源一样，同一进程的多个线程也可以共享此进程的某些资源(比如：代码、数据)，所以线程又被称为轻量级进程(lightweight process)。</p>
<h2 id="Thread类、Runnable类"><a href="#Thread类、Runnable类" class="headerlink" title="Thread类、Runnable类"></a>Thread类、<strong>Runnable</strong>类</h2><p>继承Thread类实现多线程的步骤：</p>
<ol>
<li><p>在Java中负责实现线程功能的类是java.lang.Thread 类。</p>
</li>
<li><p>可以通过创建 Thread的实例来创建新的线程。</p>
</li>
<li><p>每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。</p>
</li>
<li><p>通过调用Thread类的start()方法来启动一个线程。</p>
<p>在开发中，我们应用更多的是通过Runnable接口实现多线程。</p>
<p>一个线程对象在它的生命周期内，需要经历5个状态。</p>
</li>
</ol>
<p><strong>▪ 新生状态(New)</strong></p>
<p>   用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。</p>
<p><strong>▪ 就绪状态(Runnable)</strong></p>
<p>   处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态：</p>
<ol>
<li><p>新建线程：调用start()方法，进入就绪状态;</p>
</li>
<li><p>阻塞线程：阻塞解除，进入就绪状态;</p>
</li>
<li><p>运行线程：调用yield()方法，直接进入就绪状态;</p>
</li>
<li><p>运行线程：JVM将CPU资源从本线程切换到其他线程。</p>
</li>
</ol>
<p><strong>▪ 运行状态(Running)</strong></p>
<p>   在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。</p>
<p><strong>▪ 阻塞状态(Blocked)</strong></p>
<p>   阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。有4种原因会导致阻塞：</p>
<ol>
<li><p>执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。</p>
</li>
<li><p>执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。</p>
</li>
<li><p>线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。</p>
</li>
<li><p>join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。</p>
</li>
</ol>
<p><strong>▪ 死亡状态(Terminated)</strong></p>
<p>   死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它run()方法内的全部工作; 另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。</p>
<p>   当一个线程进入死亡状态以后，就不能再回到其它状态了。</p>
<p> 暂停线程执行常用的方法有sleep()和yield()方法，这两个方法的区别是：</p>
<ol>
<li><p>sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态。</p>
</li>
<li><p>yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权。</p>
</li>
</ol>
<h2 id="获取线程的基本信息方法"><a href="#获取线程的基本信息方法" class="headerlink" title="获取线程的基本信息方法"></a>获取线程的基本信息方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>isAlive()</td>
<td>判断线程是否还“活”着，即线程是否还未终止</td>
</tr>
<tr>
<td>getPriority()</td>
<td>获得线程的优先级数值</td>
</tr>
<tr>
<td>setPrioty()</td>
<td>设置线程的优先级数值</td>
</tr>
<tr>
<td>setName()</td>
<td>给线程一个名字</td>
</tr>
<tr>
<td>getName()</td>
<td>取得线程的名字</td>
</tr>
<tr>
<td>currentThread()</td>
<td>取得当前正在运行的线程对象，也就是取得自己本身</td>
</tr>
</tbody></table>
<ol>
<li><p>处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选。</p>
</li>
<li><p>线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5。</p>
</li>
<li><p>使用下列方法获得或设置线程对象的优先级。</p>
</li>
</ol>
<p>​     int getPriority();</p>
<p>​     void setPriority(int newPriority);</p>
<p>   注意：优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized 方法和 synchronized 块。</p>
<p><strong>▪ synchronized 方法</strong></p>
<p>   通过在方法声明中加入 synchronized关键字来声明，语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>` `<span class="keyword">synchronized</span>` `<span class="keyword">void</span>` `accessVal(``<span class="keyword">int</span>` `newVal);</span><br></pre></td></tr></table></figure>

<p>   synchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</p>
<p><strong>▪ synchronized块</strong></p>
<p>   synchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。</p>
<p>   Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。</p>
<p>   synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>``(syncObject)``　 &#123; ``　　 ``<span class="comment">//允许访问控制的代码 ``　 &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>每日进度  &gt; = 5P</code></p>
<p><a href="https://www.bilibili.com/video/av59529105/?pikaqiu">视频地址</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础记录</tag>
      </tags>
  </entry>
</search>
